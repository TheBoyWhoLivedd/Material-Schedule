import React from "react";
import { evaluate } from "mathjs";
import {
  DataGrid,
  Button,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
} from "@material-ui/core";

export function validateBodmasString(bodmasString) {
  // Check if the string is empty
  if (bodmasString.length === 0) {
    return false;
  }

  // Check if the string contains any characters other than numbers, parentheses,
  // and the four basic arithmetic operators
  const validCharacters = /^[0-9()+-/*]+$/;
  if (!validCharacters.test(bodmasString)) {
    return false;
  }

  // Check if the string has balanced parentheses
  const parentheses = bodmasString
    .split("")
    .filter((char) => char === "(" || char === ")");
  let openParentheses = 0;
  for (const char of parentheses) {
    if (char === "(") {
      openParentheses++;
    } else {
      openParentheses--;
    }

    if (openParentheses < 0) {
      return false;
    }
  }

  if (openParentheses !== 0) {
    return false;
  }

  return true;
}

export function calculateBodmas(bodmasString) {
  // Check if the string is empty or not a valid BODMAS string
  if (!bodmasString || !validateBodmasString(bodmasString)) {
    return NaN;
  }

  // Use a regular expression to find all sub-expressions enclosed in parentheses
  const regex = /\(([^()]+)\)/g;
  let match = regex.exec(bodmasString);

  // Replace each sub-expression with its calculated result
  while (match != null) {
    const subExpression = match[1];
    const result = calculateBodmas(subExpression);
    bodmasString = bodmasString.replace(match[0], result);
    match = regex.exec(bodmasString);
  }

  // Split the string into an array of numbers and operators
  const tokens = bodmasString.split(/([+-/*])/).filter((token) => token !== "");

  // Calculate the result of the expression using the BODMAS rules
  let result = parseInt(tokens[0], 10);
  for (let i = 1; i < tokens.length; i += 2) {
    const operator = tokens[i];
    const operand = parseInt(tokens[i + 1], 10);

    switch (operator) {
      case "+":
        result += operand;
        break;
      case "-":
        result -= operand;
        break;
      case "*":
        result *= operand;
        break;
      case "/":
        result /= operand;
        break;
    }
  }

  return result;
}

// function that checks if input has a proper bodmas string and returns value.

export const BodmasCalculator = () => {
  const [input, setInput] = React.useState("");
  const [result, setResult] = React.useState("");
  const [error, setError] = React.useState(false);

  const handleChange = (event) => {
    const input = event.target.value;
    // Use a regular expression to validate the input as a proper bodmas string
    const isValid =
      /^\(*(\d+(\.\d+)*|\((\d+(\.\d+)*|\(*(\d+(\.\d+)*|\((\d+(\.\d+)*|[\+-\/\*]))*\)*)*\)*)*[\+-\/\*]*)+\)*$/.test(
        input
      );

    const isValidOrNumber =
      /^(\(*(\d+(\.\d+)*|\((\d+(\.\d+)*|\(*(\d+(\.\d+)*|\((\d+(\.\d+)*|[\+-\/\*]))*\)*)*\)*)*[\+-\/\*]*)+\)*|\d+(\.\d+)*)$/.test(
        input
      );

    const isValidOrNumberOrEmpty =
      /^(\(*(\d+(\.\d+)*|\((\d+(\.\d+)*|\(*(\d+(\.\d+)*|\((\d+(\.\d+)*|[\+-\/\*]))*\)*)*\)*)*[\+-\/\*]*)+\)*|\d+(\.\d+)*|)$/.test(
        input
      );

    // const isValid =
    //   /^\(*(\d+(\.\d+)*|\((\d+(\.\d+)*|\(*(\d+(\.\d+)*|\((\d+(\.\d+)*|[\+-\/\*]))*\)*)*\)*)*[\+-\/\*]*)+\)*$/.test(
    //     input
    //   );

    if (!isValid) {
      // If the input is not valid, display an error message
      setInput(input);
      setError(true);
    } else {
      // If the input is valid, perform the calculation and display the result
      // Use a safer method for performing the calculation, such as the mathjs library
      const result = evaluate(input);
      setInput(input);
      setResult(result);
      setError(false);
    }
  };

  return (
    <form>
      <input type="text" value={input} onChange={handleChange} />
      <div>{result}</div>
      <div>{error}</div>
    </form>
  );
};

const validateExpression = (input) => {
  // Use the updated regex to validate the input
  const validExpression =
    /^(\+|[+-]?)(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?((\s+)?(?<=\s|^|\()[-+*/^\(\)](\s+)?)*[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?$/;
  if (!validExpression.test(input)) {
    return false;
  }

  // Use a stack to check that the parentheses are used correctly
  const stack = [];
  for (const c of input) {
    if (c === "(") {
      stack.push(c);
    } else if (c === ")") {
      if (stack.length === 0) {
        return false;
      }
      stack.pop();
    }
  }

  // Return true if the stack is empty, indicating that all opening
  // parentheses have a matching closing parenthesis
  return stack.length === 0;
};

function DeleteButton({ id }) {
  const [open, setOpen] = React.useState(false);

  const handleClickOpen = () => {
    setOpen(true);
  };

  const handleClose = () => {
    setOpen(false);
  };

  const handleDelete = () => {
    // Perform delete operation here using the `id` parameter
    setOpen(false);
  };

  return (
    <div>
      <Button variant="outlined" color="secondary" onClick={handleClickOpen}>
        Delete
      </Button>
      <Dialog
        open={open}
        onClose={handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{"Confirm Delete"}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">
            Are you sure you want to delete this item? This action cannot be
            undone.
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose} color="primary">
            Cancel
          </Button>
          <Button onClick={handleDelete} color="secondary" autoFocus>
            Delete
          </Button>
        </DialogActions>
      </Dialog>
    </div>
  );
}

function DataGridExample() {
  const columns = [
    { field: "id", title: "ID" },
    { field: "name", title: "Name" },
    {
      field: "actions",
      title: "Actions",
      render: (row) => <DeleteButton id={row.id} />,
    },
  ];

  const rows = [
    { id: 1, name: "Row 1" },
    { id: 2, name: "Row 2" },
    //...
  ];

  return <DataGrid columns={columns} rows={rows} />;
}


const Schedule = require("../models/Schedule");
const User = require("../models/User");
const mongoose = require("mongoose");

// @desc Update a schedule
// @route PUT /schedules/:id
// @access Private
async function updateScheduleMaterial(req, res) {
  try {
    // Find the element being updated
    const element = await Schedule.findById(req.params.id);

    // If the element is not found, return a 404 error
    if (!element) return res.status(404).json({ message: "Element not found" });

    // If the element name is "concrete", fetch all the related objects
    if (element.elementName === "concrete") {
      const concreteElements = await Schedule.find({
        elementName: "concrete",
        relatedElement: element._id,
      });
      // Update all the related objects in a single operation
      await Schedule.updateMany(
        {
          _id: { $in: concreteElements.map((e) => e._id) },
        },
        req.body
      );
    } else {
      // Otherwise, update the element as usual
      element.set(req.body);
      await element.save();
    }

    res.json({ message: "Element updated" });
  } catch (error) {
    res.status(500).json({ message: "Error updating element" });
  }
}



